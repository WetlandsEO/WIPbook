[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WIP Tutorial",
    "section": "",
    "text": "Preface\n\nWetland inventories are essential for tracking loss of wetlands. The WIP tool was developed to identify wetlands that are missing from existing wetland inventories. Our wetland indicator framework, which includes spatial variables representing vegetation, hydrology, soils, and multi-scale topographic attributes can be used to quantify probability of wetland occurrence, as well as predict the type of wetland. Our wetland indicator framework provides a flexible approach that can be adapted to identify diverse wetland types across varied landscapes. This framework is shown below\n\nThe following article provides a skeleton of how to run this tool in the R programming language. It must be noted that there are some things, including many of the wetland indicators, like vegetation and soils, that must be obtained externally for now. However, the development of topographical indices and everything to do with the building and running of the model, can be run in R."
  },
  {
    "objectID": "run_model.html#parameters",
    "href": "run_model.html#parameters",
    "title": "Running Model",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\nInputs\nDescription\n\n\n\n\nin_rasts\nList input that contains all the rasters that are chosen to be included in the model\n\n\npoly_inputs\nList input that contains the polygons that are chosen to be included in the model, if any\n\n\nref_raster\nSpatial raster input of the reference raster, which is used to align all of the other inputs. The DEM is usually a good choice here\n\n\nmodel_type\nString input indicating type of machine learning model. Options include “forest”, “tree”, “glm”, and “knn”\n\n\nclass_rast\nBinary parameter that determines whether the output will be probability rasters or a classification raster\n\n\nexport\nBinary parameter that determines whether or not the function exports the output to a file"
  },
  {
    "objectID": "run_model.html#executing-the-function",
    "href": "run_model.html#executing-the-function",
    "title": "Running Model",
    "section": "Executing the function",
    "text": "Executing the function\n\nprob_multi &lt;- run_model(multi_mod, \n                        in_rasts = c(elev1, elev2, elev3),\n                        ref_raster = dem)\n\n[1] \"Formatting inputs\"\n[1] \"Stacking rasters\"\n[1] \"Running model\"\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n[1] \"Done!\"\n\nprob_simple &lt;- run_model(simple_mod, \n                        in_rasts = c(elev1, elev2, elev3),\n                        ref_raster = dem)\n\n[1] \"Formatting inputs\"\n[1] \"Stacking rasters\"\n[1] \"Running model\"\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n[1] \"Done!\"\n\nprob_multi\n\nclass       : SpatRaster \ndimensions  : 1287, 1557, 5  (nrow, ncol, nlyr)\nresolution  : 3.999648, 3.998959  (x, y)\nextent      : 551135.5, 557362.9, 5184713, 5189859  (xmin, xmax, ymin, ymax)\ncoord. ref. : NAD83 / UTM zone 10N (EPSG:26910) \nsource      : spat_BxpWm5qgxmk3cQS_27760.tif \nnames       : Freshw~etland, Freshw~etland, Freshw~r.Pond, Riverine,  UPL \nmin values  :         0.000,         0.000,          0.00,    0.000, 0.01 \nmax values  :         0.865,         0.805,          0.83,    0.865, 1.00"
  },
  {
    "objectID": "run_model.html#classification-option",
    "href": "run_model.html#classification-option",
    "title": "Running Model",
    "section": "Classification Option",
    "text": "Classification Option\nInstead of returning probabilities, the run_model function also has an option to return a classification raster. This is often useful for when we testing the model to predict multiple types of wetlands (multi-class classification), since it is easier to comprehend one prediction rather than lots of probabilities.\n\nclass_multi &lt;- run_model(multi_mod, class_rast = TRUE,\n                        in_rasts = c(elev1, elev2, elev3),\n                        ref_raster = dem)\n\n[1] \"Formatting inputs\"\n[1] \"Stacking rasters\"\n[1] \"Running model\"\n[1] \"Done!\"\n\nclass_multi\n\nclass       : SpatRaster \ndimensions  : 1287, 1557, 1  (nrow, ncol, nlyr)\nresolution  : 3.999648, 3.998959  (x, y)\nextent      : 551135.5, 557362.9, 5184713, 5189859  (xmin, xmax, ymin, ymax)\ncoord. ref. : NAD83 / UTM zone 10N (EPSG:26910) \nsource(s)   : memory\ncategories  : class \nname        :                       class \nmin value   : Freshwater Emergent Wetland \nmax value   :                         UPL"
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "This section contains all of the functions mentioned throughout this whole book."
  },
  {
    "objectID": "train_pts_fun.html",
    "href": "train_pts_fun.html",
    "title": "1  build_train_pts",
    "section": "",
    "text": "build_train_pts &lt;- function(region_poly, wet_poly, multi_class = FALSE,\n                            wet_types = c(\"Freshwater Forested/Shrub Wetland\",\n                                          \"Freshwater Emergent Wetland\",\n                                          \"Freshwater Pond\",\n                                          \"Estuarine and Marine Wetland\",\n                                          \"Riverine\", \"Lake\",\n                                          \"Estuarine and Marine Deepwater\",\n                                          \"Other\"),\n                            wet_field = \"WETLAND_TY\",\n                            sample_points = c(50, 150), \n                            export = FALSE) {\n  \n  # Loads in polygons if input is a file name\n  if(is.character(wet_poly[[1]])) {\n    temp_poly &lt;- list()\n    for(i in 1:length(wet_poly)) {\n      temp_poly[[i]] &lt;- terra::vect(wet_poly) \n    }\n    wet_poly &lt;- temp_poly\n  }\n  \n  if(is.character(region_poly)) {\n    region_poly &lt;- terra::vect(region_poly)\n  }\n  \n  # Filters the wetland polygons to only include wanted types\n  wet_poly &lt;- wet_poly[unlist(wet_poly[[wet_field]]) %in% wet_types]\n  if(length(wet_poly) == 0) {\n    stop(\"No wetlands to sample!\")\n  }\n  \n  # Cropping the wetland polygon(s) to the overall region\n  wet_poly &lt;- terra::project(wet_poly, region_poly)\n  wet_poly &lt;- terra::crop(wet_poly, region_poly)\n  \n  # Checks if output is supposed to be more than two classes before proceeding\n  if(multi_class) {\n    # Initialize parameters\n    train_crds &lt;- NULL\n    train_atts &lt;- c()\n    wet_samp &lt;- sample_points[1]\n    up_samp &lt;- sample_points[2]\n    \n    # Sample points for each wetland class\n    for(i in 1:length(wet_types)) {\n      temp_poly &lt;- wet_poly[unlist(wet_poly[[wet_field]]) == wet_types[i]]\n      \n      # Checking if polygons of that type of wetland exist\n      if(length(temp_poly) == 0) {\n        warning(paste0(wet_types[i], \" not found!\"))\n      }\n      else {\n        wet_crds &lt;- NULL\n        samp_wet_pts &lt;- terra::spatSample(temp_poly, wet_samp)\n        coords &lt;- terra::crds(samp_wet_pts)\n        wet_crds &lt;- rbind(wet_crds, coords)\n        \n        num_coords &lt;- nrow(coords)\n        while(num_coords &lt; wet_samp) {\n          new_points &lt;- terra::spatSample(temp_poly,\n                                          wet_samp-(num_coords))\n          new_crds &lt;- terra::crds(new_points)\n          wet_crds &lt;- rbind(wet_crds, new_crds)\n          num_coords &lt;- num_coords + nrow(new_crds)\n        }\n        \n        train_crds &lt;- rbind(train_crds, wet_crds)\n        train_atts &lt;- c(train_atts, rep(wet_types[i], wet_samp))\n      }\n    }\n    \n    # Sample points from non-wetland areas\n    up_poly &lt;- terra::erase(region_poly, wet_poly)\n    samp_up_pts &lt;- terra::spatSample(up_poly, up_samp)\n    up_crds &lt;- terra::crds(samp_up_pts)\n    \n    # Create the points\n    train_crds &lt;- rbind(train_crds, up_crds)\n    train_atts &lt;- c(train_atts, rep(\"UPL\", up_samp))\n    train_atts &lt;- data.frame(class = factor(train_atts))\n    pts &lt;- terra::vect(train_crds, atts = train_atts,\n                       crs = terra::crs(region_poly))\n  } else {\n    # Sample the wetland points\n    wet_samp &lt;- sample_points[1]\n    up_samp &lt;- sample_points[2]\n    wet_crds &lt;- NULL\n    \n    num_points &lt;- c()\n    total_area &lt;- sum(terra::expanse(wet_poly))\n    for(i in 1:length(wet_types)) {\n      temp_poly &lt;- wet_poly[unlist(wet_poly[[wet_field]]) == wet_types[i]]\n      \n      # Checking if polygons of that type of wetland exist\n      if(length(temp_poly) == 0) {\n        warning(paste0(wet_types[i], \" not found!\"))\n      }\n      else {\n        prop_area &lt;- sum(terra::expanse(temp_poly)) / total_area\n        num_points[i] &lt;- round(prop_area * wet_samp)\n        if(num_points[i] != 0) {\n          samp_wet_pts &lt;- terra::spatSample(temp_poly,\n                                            num_points[i])\n          coords &lt;- terra::crds(samp_wet_pts)\n          wet_crds &lt;- rbind(wet_crds, coords)\n          num_coords &lt;- nrow(coords)\n          while(num_coords &lt; num_points[i]) {\n            new_points &lt;- terra::spatSample(temp_poly,\n                                            num_points[i]-(num_coords))\n            new_crds &lt;- terra::crds(new_points)\n            wet_crds &lt;- rbind(wet_crds, new_crds)\n            num_coords &lt;- num_coords + nrow(new_crds)\n          }\n        }\n      }\n    }\n    if(sum(num_points, na.rm = T) != wet_samp) {\n      stop(\"Please try another sample size\")\n    }\n    \n    # Sample points from non-wetland areas\n    up_poly &lt;- terra::erase(region_poly, wet_poly)\n    samp_up_pts &lt;- terra::spatSample(up_poly, up_samp)\n    up_crds &lt;- terra::crds(samp_up_pts)\n    \n    # Create the points\n    train_crds &lt;- rbind(wet_crds, up_crds)\n    train_atts &lt;- data.frame(class = factor(c(rep(\"WET\", wet_samp),\n                                              rep(\"UPL\", up_samp))))\n    pts &lt;- terra::vect(train_crds, atts = train_atts,\n                       crs = terra::crs(region_poly))\n  }\n  \n  # Return the points and exports them, if desired\n  if(export) {\n    terra:writeVector(pts, filename = \"trainingdata.shp\")\n  }\n  \n  return(pts)\n}"
  },
  {
    "objectID": "fun_s.html",
    "href": "fun_s.html",
    "title": "2  surface_met",
    "section": "",
    "text": "surface_met &lt;- function(DEM, len, export = FALSE,\n                        elev_dev = c(\"grad\", \"plan\", \"prof\", \"dev\", \"twi\")) {\n  # Checks if inputs are file names and loads them in\n  if(is.character(DEM)) {\n    if(!file.exists(DEM)) {\n      stop(\"Cannot find DEM file\")\n    }\n    DEM &lt;- terra::rast(DEM)\n  }\n  # Sets up the resolution\n  k &lt;- round(len/terra::res(DEM)[1])\n  if (k %% 2 == 0) {\n    k &lt;- k + 1\n  }\n  \n  # Initialize the inputs for the model\n  in_rast &lt;- list()\n  \n  if(\"grad\" %in% elev_dev) {\n    j &lt;- k/2 - 0.5\n    \n    xl.end &lt;- matrix(c(1, rep(NA_real_, times=k-1)), ncol=k, nrow=1)\n    xr.end &lt;- matrix(c(rep(NA_real_, times=k-1), 1), ncol=k, nrow=1)\n    \n    x.mids &lt;- matrix(NA_real_, ncol=k, nrow=j-1)\n    \n    xl.mid &lt;- matrix(c(2, rep(NA_real_, times=k-1)), ncol=k, nrow=1)\n    xr.mid &lt;- matrix(c(rep(NA_real_, times=k-1), 2), ncol=k, nrow=1)\n    \n    xl.mat &lt;- rbind(xl.end, x.mids, xl.mid, x.mids, xl.end)\n    xr.mat &lt;- rbind(xr.end, x.mids, xr.mid, x.mids, xr.end)\n    \n    yt.end &lt;- matrix(c(1, rep(NA_real_, times=k-1)), ncol=1, nrow=k)\n    yb.end &lt;- matrix(c(rep(NA_real_, times=k-1), 1), ncol=1, nrow=k)\n    \n    y.mids &lt;- matrix(NA_real_, ncol=j-1, nrow=k)\n    \n    yt.mid &lt;- matrix(c(2, rep(NA_real_, times=k-1)), ncol=1, nrow=k)\n    yb.mid &lt;- matrix(c(rep(NA_real_, times=k-1), 2), ncol=1, nrow=k)\n    \n    yt.mat &lt;- cbind(yt.end, y.mids, yt.mid, y.mids, yt.end)\n    yb.mat &lt;- cbind(yb.end, y.mids, yb.mid, y.mids, yb.end)\n    \n    dz.dx.l &lt;- terra::focal(DEM, xl.mat, fun=sum, na.rm=T, na.policy = \"omit\")\n    dz.dx.r &lt;- terra::focal(DEM, xr.mat, fun=sum, na.rm=T, na.policy = \"omit\")\n    dz.dy.t &lt;- terra::focal(DEM, yt.mat, fun=sum, na.rm=T, na.policy = \"omit\")\n    dz.dy.b &lt;- terra::focal(DEM, yb.mat, fun=sum, na.rm=T, na.policy = \"omit\")\n    \n    wts.l &lt;- terra::focal(!is.na(DEM), w=xl.mat, fun=sum, na.rm=TRUE,\n                          na.policy = \"omit\")\n    wts.r &lt;- terra::focal(!is.na(DEM), w=xr.mat, fun=sum, na.rm=TRUE,\n                          na.policy = \"omit\")\n    wts.t &lt;- terra::focal(!is.na(DEM), w=yt.mat, fun=sum, na.rm=TRUE,\n                          na.policy = \"omit\")\n    wts.b &lt;- terra::focal(!is.na(DEM), w=yb.mat, fun=sum, na.rm=TRUE,\n                          na.policy = \"omit\")\n    dz.dx &lt;- ((dz.dx.r/wts.r) - (dz.dx.l/wts.l))/(2*j*terra::xres(DEM))\n    dz.dy &lt;- ((dz.dy.t/wts.t) - (dz.dy.b/wts.b))/(2*j*terra::yres(DEM))\n    \n    grad &lt;- sqrt(dz.dx^2 + dz.dy^2)\n    in_rast &lt;- c(in_rast, grad)\n    \n    names(in_rast)[length(in_rast)] &lt;- paste0(\"grad\", len)\n  }\n  \n  if(\"plan\" %in% elev_dev) {\n    if (\"prof\" %in% elev_dev) {\n      both &lt;- MultiscaleDTM::Qfit(DEM, metrics = c(\"planc\", \"profc\"),\n                                  w = k, na.rm = T)\n      in_rast &lt;- c(in_rast, both[[1]], both[[2]])\n      \n      names(in_rast)[length(in_rast)-1] &lt;- paste0(\"plan\", len)\n      names(in_rast)[length(in_rast)] &lt;- paste0(\"prof\", len)\n    } else {\n      plan &lt;- MultiscaleDTM::Qfit(DEM, metrics = \"planc\", w = k, na.rm = T)\n      in_rast &lt;- c(in_rast, plan)\n      \n      names(in_rast)[length(in_rast)] &lt;- paste0(\"plan\", len)\n    }\n  } else if(\"prof\" %in% elev_dev) {\n    prof &lt;- MultiscaleDTM::Qfit(DEM, metrics = \"profc\", w = k, na.rm = T)\n    in_rast &lt;- c(in_rast, prof)\n    \n    names(in_rast)[length(in_rast)] &lt;- paste0(\"prof\", len)\n  }\n  \n  if(\"dev\" %in% elev_dev) {\n    dev &lt;- (DEM - focal(DEM, w = k, fun = \"mean\", na.rm = T, na.policy = \"omit\")) / focal(DEM, w = k, fun = \"sd\", na.rm = T, na.policy = \"omit\") \n    in_rast &lt;- c(in_rast, rast_dev)\n    \n    names(in_rast)[length(in_rast)] &lt;- paste0(\"dev\", len)\n  }\n  \n  if(\"twi\" %in% elev_dev) {\n    topidx &lt;- topmodel::topidx(terra::as.matrix(DEM), res = terra::res(DEM)[1])\n    a &lt;- terra::setValues(DEM, topidx$area)\n    twi &lt;- a / tan(terra::terrain(DEM, unit = \"radians\"))\n    terra::values(twi) &lt;- ifelse(terra::values(twi) &lt; 0, 0, terra::values(twi))\n    twi &lt;- terra::focal(twi, w = k, mean, na.rm = T, na.policy = \"omit\")\n    \n    in_rast &lt;- c(in_rast, twi)\n    \n    names(in_rast)[length(in_rast)] &lt;- paste0(\"twi\", len)\n  }\n  \n  # Exports the surface metrics\n  if(export) {\n    for(i in 1:length(in_rast)) {\n      writeRaster(in_rast[[i]],\n                  filename = paste0(names(in_rast[i]), len, \".tif\"))\n    }\n  }\n  return(in_rast)\n}"
  },
  {
    "objectID": "fun_s1.html",
    "href": "fun_s1.html",
    "title": "3  surface_met1",
    "section": "",
    "text": "surface_met1 &lt;- function(len, metrics = c(\"grad\", \"plan\", \"prof\", \"dev\"),\n                         dem_dir, exec_dir, out_dir=getwd(), re_sample = NA) {\n  \n  # Checking to see if directories exist\n  if(!file.exists(dem_dir)) {\n    stop(\"DEM directory does not exist!\")\n  }\n  \n  if(!dir.exists(exec_dir)) {\n    stop(\"Executable Files directory does not exist!\")\n  }\n  \n  # Prepare inputs\n  dem_dir &lt;- normalizePath(dem_dir)\n  out_dir &lt;- normalizePath(out_dir)\n  if(!endsWith(out_dir, \"\\\\\")) {\n    out_dir &lt;- paste0(out_dir, \"\\\\\")\n  }\n  exec_dir &lt;- normalizePath(exec_dir)\n  \n  # Write input file\n  file_name &lt;- paste0(out_dir, \"input_makeGrids.txt\")\n  file.create(file_name)\n  \n  writeLines(c(\"# Input file for makeGrids\",\n               \"\",\n               paste0(\"DEM: \", dem_dir),\n               paste0(\"SCRATCH DIRECTORY: \", out_dir),\n               paste0(\"LENGTH SCALE: \", len)), con = file_name)\n  \n  if(\"grad\" %in% metrics) {\n    write(paste0(\"GRID: GRADIENT, OUTPUT FILE = \", out_dir, \"grad\", len, \".flt\"),\n          file = file_name, append = T) \n  }\n  \n  if(\"plan\" %in% metrics) {\n    write(paste0(\"GRID: PLAN CURVATURE, OUTPUT FILE = \", out_dir,\n                 \"plan\", len), file = file_name, append = T)\n  }\n  \n  if(\"prof\" %in% metrics) {\n    write(paste0(\"GRID: PROFILE CURVATURE, OUTPUT FILE = \", out_dir,\n                 \"prof\", len), file = file_name, append = T)\n  }\n  \n  # Run surface metrics sans DEV\n  system(paste0(exec_dir, \"\\\\makeGrids\"), input = file_name)\n  \n  # Writing input file for DEV\n  if (\"dev\" %in% metrics) {\n    if(is.na(re_sample)) {\n      stop(\"Set re_sample level\")\n    }\n    \n    # Prepare inputs\n    file_name &lt;- paste0(out_dir, \"input_localRelief.txt\")\n    rad &lt;- len / 2\n    \n    # Create and write input file\n    file.create(file_name)\n    writeLines(c(\"# Input file for LocalRelief\",\n                 \"# Creating by surfaceMetrics.R\",\n                 paste0(\"# On \", Sys.time()),\n                 paste0(\"DEM: \", dem_dir),\n                 paste0(\"SCRATCH DIRECTORY: \", out_dir),\n                 paste0(\"RADIUS: \", rad),\n                 paste0(\"DOWN SAMPLE: \", re_sample),\n                 paste0(\"SAMPLE INTERVAL: \", re_sample),\n                 paste0(\"OUTPUT LOCAL RASTER: \", out_dir, \"local\", len)),\n               con = file_name)\n    \n    # Run DEV in console\n    system(paste0(exec_dir, \"\\\\localRelief\"), input = file_name)\n  }\n}"
  },
  {
    "objectID": "build_model_fun.html",
    "href": "build_model_fun.html",
    "title": "4  build_model",
    "section": "",
    "text": "build_model &lt;- function(in_rasts, poly_inputs = list(), train, ref_raster,\n                        model_type = \"forest\", model_params = list(ntree = 200),\n                        class_field_name = \"class\") {\n  \n  # Checking if input rasters are file names, then load them in\n  if(is.character(in_rasts[1])) {\n    temp_rast &lt;- rep(list(), length(in_rasts))\n    for(i in 1:length(in_rasts)) {\n      temp_rast[[i]] &lt;- terra::rast(in_rasts[i])\n    }\n    names(temp_rast) &lt;- in_rasts\n    in_rasts &lt;- temp_rast\n  }\n  \n  # Checks if there are any polygon inputs\n  if(length(poly_inputs) &gt; 0) {\n    \n    # Checking to see the polygon inputs are filenames\n    if(is.character(poly_inputs[[1]])) {\n      temp_poly &lt;- rep(list(), length(poly_inputs))\n      for(i in 1:length(poly_inputs)) {\n        if(!file.exists(poly_inputs[[i]])) {\n          stop(paste0(\"Cannot find poly input file:\", poly_inputs[i]))\n        }\n        temp_poly[[i]] &lt;- terra::vect(poly_inputs[i]) \n      }\n      names(temp_poly) &lt;- poly_inputs\n      poly_inputs &lt;- temp_poly\n    }\n    \n    # Rasterize polygon inputs\n    for(i in 1:length(poly_inputs)) {\n      vr_name &lt;- names(poly_inputs)[i]\n      temp_rast &lt;- terra::rasterize(poly_inputs[i], ref_raster, field = vr_name)\n      in_rasts &lt;- c(in_rasts, temp_rast)\n    }\n  }\n  \n  # Ensure that all inputs are covering the same area\n  print(\"Formatting inputs\")\n  for(i in 1:length(in_rasts)) {\n    in_rasts[[i]] &lt;- terra::project(in_rasts[[i]], ref_raster)\n    in_rasts[[i]] &lt;- terra::crop(in_rasts[[i]], ref_raster)\n  }\n  \n  # Set up training data\n  print(\"Setting up training data\")\n  df_train &lt;- data.frame(class = factor(as.vector(unlist(train[[class_field_name]]))))\n  for(i in 1:length(in_rasts)) {\n    vals &lt;- terra::extract(in_rasts[[i]], train, ID = F)\n    df_train &lt;- cbind(df_train, vals)\n  }\n  df_train &lt;- na.omit(df_train)\n  colnames(df_train) &lt;- c(\"class\", names(in_rasts))\n  \n  # Build the model\n  print(\"Building model\")\n  if(model_type == \"forest\"){\n    mod &lt;- randomForest::randomForest(class ~ ., data = df_train, \n                                      ntree = model_params$ntree)\n  } else if (model_type == \"tree\") {\n    mod &lt;- randomForest::randomForest(class ~ ., data = df_train, ntree = 1)\n  } else if(model_type == \"glm\") {\n    if(length(levels(df_train$class)) &gt; 2) {\n      mod &lt;- nnet::multinom(class ~ ., data = df_train)\n    } else {\n      mod &lt;- glm(class ~ ., data = df_train, family = \"binomial\")\n    }\n  } else if(model_type == \"knn\") {\n    mod &lt;- caret::knn3(formula = class ~ ., data = df_train, k = model_params$k)\n  } else {\n    stop(\"Incorrect model type\")\n  }\n  \n  print(\"Done!\")\n  return(mod)\n}"
  },
  {
    "objectID": "run_model_fun.html",
    "href": "run_model_fun.html",
    "title": "5  run_model",
    "section": "",
    "text": "run_model &lt;- function(mod, in_rasts = list(), poly_inputs = list(), ref_raster,\n                      model_type = \"forest\", class_rast = FALSE,\n                      export = FALSE) {\n  \n  # Checking if inputs are file names, then load them in\n  if(is.character(in_rasts[1])) {\n    temp_rast &lt;- rep(list(), length(in_rasts))\n    for(i in 1:length(in_rasts)) {\n      temp_rast[[i]] &lt;- terra::rast(in_rasts[i])\n    }\n    names(temp_rast) &lt;- in_rasts\n    in_rasts &lt;- temp_rast\n  }\n  \n  if(length(poly_inputs) &gt; 0) {\n    if(is.character(poly_inputs[[1]])) {\n      temp_poly &lt;- rep(list(), length(poly_inputs))\n      for(i in 1:length(poly_inputs)) {\n        if(!file.exists(poly_inputs[[i]])) {\n          stop(paste0(\"Cannot find poly input file:\", poly_inputs[i]))\n        }\n        temp_poly[[i]] &lt;- terra::vect(poly_inputs[i]) \n      }\n      names(temp_poly) &lt;- poly_inputs\n      poly_inputs &lt;- temp_poly\n    }\n    for(i in 1:length(poly_inputs)) {\n      vr_name &lt;- names(poly_inputs)[i]\n      temp_rast &lt;- terra::rasterize(poly_inputs[i], ref_raster, field = vr_name)\n      in_rasts &lt;- c(in_rasts, temp_rast)\n    }\n  }\n  \n  # Ensure that all inputs are covering the same area\n  print(\"Formatting inputs\")\n  for(i in 1:length(in_rasts)) {\n    in_rasts[[i]] &lt;- terra::project(in_rasts[[i]], ref_raster)\n    in_rasts[[i]] &lt;- terra::crop(in_rasts[[i]], ref_raster)\n  }\n  \n  # Stacks the rasters on top of each other to create one raster\n  print(\"Stacking rasters\")\n  input_raster &lt;- in_rasts[[1]]\n  if(length(in_rasts) &gt; 1) {\n    for(i in 2:length(in_rasts)) {\n      input_raster &lt;- c(input_raster, in_rasts[[i]])\n    }\n  }\n  names(input_raster) &lt;- names(in_rasts)\n  \n  # Run the model\n  print(\"Running model\")\n  \n  if(class_rast) {\n    if(isTRUE(mod$call[[1]] == \"glm\")) {\n      output &lt;- terra::predict(input_raster, mod, na.rm = T,\n                               type = \"response\")\n      vals &lt;- terra::values(output)\n      vals &lt;- ifelse(vals &gt; 0.5, \"WET\", \"UPL\")\n      terra::values(output) &lt;- vals\n      \n    } else {\n      output &lt;- terra::predict(input_raster, mod, na.rm = T)\n    }\n    \n  } else {\n    if(isTRUE(mod$call[[1]] == \"glm\")) {\n      output &lt;- terra::predict(input_raster, mod, na.rm = T,\n                               type = \"response\")\n    } else {\n      output &lt;- terra::predict(input_raster, mod, na.rm = T, type = \"prob\")\n    }\n  }  \n  \n  if(export) {\n    for(i in 1:length(output)) {\n      file_name &lt;- paste0(names(input_raster)[i], \"prob.tif\")\n      terra::writeRaster(output[[i]], filename = file_name)\n    }\n  }\n  \n  print(\"Done!\")\n  return(output)\n}"
  }
]